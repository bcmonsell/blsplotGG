#' Convert matrix of ACFs or PACFs generated by X-13ARIMA-SEATS \code{identify} spec to a list object
#'
#' Generates a list of the ACF or PACF generated by the \code{identify} spec
#'
#' Version 2.0, 10/23/2024
#'
#' @param seas_obj \code{seas} object generated from a call of \code{seas} on a single time series
#'        This is a required entry.
#' @param this_plot Character string; three character code for the type of plot to be generated.
#'        Allowed entries are \code{"iac"} (sample autocorrelation function, default), 
#'             \code{"ipf"} (sample partial autocorrelation function).
#' @return A list of matrices of ACF or PACFs produced for different orders of differncing.
#'         The list entries are named based on the orders of differencing (\code{d0sd0} denotes 
#'         no regular difference, no seasonal difference, \code{d1sd0} denotes 
#'         one regular difference, no seasonal difference, etc.)
#'
#' @author Brian C. Monsell, \email{monsell.brian@@bls.gov} or \email{bcmonsell@@gmail.com}
#' @examples
#' shoes_identify_seas <- 
#'    seasonal::seas(shoes2008, 
#'                   identify.diff = c(0, 1),
#'                   identify.sdiff = c(0, 1),
#'                   identify.save = c("iac", "ipc"),
#'                   arima.model = "(0 1 1)(0 1 1)", 
#'                   transform.function = "log", 
#'                   forecast.maxlead = 36,
#'				     check.maxlag = 36,
#' 				     check.acflimit = 1.96,
#' 				     check.qlimit = 0.01,
#'                   check.print = c( 'pacf', 'pacfplot' ))
#' shoes_identify_acf_list <- 
#'     convert_identify_acf(shoes_identify_seas, 'iac')
#' shoes_identify_pacf_list <- 
#'     convert_identify_acf(shoes_identify_seas, 'ipc')
#' @export
convert_identify_acf <- 
	function(seas_obj = NULL, this_plot = 'iac') {
	  
	  # check if a value is specified for \code{seas_obj}
	  if (is.null(seas_obj)) {
	    stop("must specify a seas object")
	  } else {
	    # check if a seas object is specified for \code{seas_obj}
	    if (!inherits(seas_obj, "seas")) {
	      stop("First argument must be a seas object")
	    }
	  }
	  
	  acf_type_all <- c("iac", "ipc")
	  if(sum(match(acf_type_all, this_plot), na.rm = TRUE) == 0) {
	    stop(paste("ACF plot type not valid:", this_plot))
	  }
	  
	  # generate full acf matrix
	  full_acf_matrix <- seasonal::series(seas_obj, this_plot)
	  full_colnames   <- colnames(full_acf_matrix)
	  full_ncol       <- length(full_colnames)
	  full_index      <- seq(1, full_ncol-2)
	  
	  full_diff  <- unique(full_acf_matrix[, full_ncol-1])
	  full_sdiff <- unique(full_acf_matrix[, full_ncol])
	  
	  # generate number of unique sets of differencing orders
	  ndiff  <- length(full_diff)
	  nsdiff <- length(full_sdiff)
	  nboth  <- ndiff * nsdiff
	  
	  # initialize list of acf results
	  this_acf_list <- list()
	  
	  # process each combination of differences
	  for (i in 1:ndiff) {
	    for (j in 1:nsdiff) {
	      # generate key for acf list
	      this_diff  <- full_diff[i]
	      this_sdiff <- full_sdiff[j]
	      this_key <- paste0("d", this_diff, "_sd", this_sdiff)
	      
	      # extract acf matrix for specific orders of differencing 
	      # from \code{full_acf matrix}
	      this_index <- 
	        full_acf_matrix[,"diff"]  == this_diff & 
	        full_acf_matrix[,"sdiff"] == this_sdiff
	      this_acf_matrix <- full_acf_matrix[this_index, full_index]
	      
	      # set column names
	      colnames(this_acf_matrix) <- full_colnames[full_index]
	      
	      # save acf matrix into list
	      this_acf_list[[this_key]] <- this_acf_matrix
	    }
	  }
	  
	  # return acf list
	  return(this_acf_list)
	  
	}